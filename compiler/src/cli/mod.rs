use crate::analyzer::SemanticAnalyzer;
use crate::codegen::CodeGenerator;
use crate::lexer::Lexer;
use crate::parser::Parser;
use crate::runtime::{HttpRequest, LoafServer};
use anyhow::{anyhow, Result};
use clap::{Parser as ClapParser, Subcommand};
use std::fs;
use std::path::PathBuf;
use std::collections::HashMap;

/// Command-line interface for the loaf language compiler
#[derive(ClapParser)]
#[command(name = "loaf")]
#[command(about = "A declarative JSON-style programming language compiler")]
#[command(version = "0.1.0")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Compile a loaf source file to bytecode
    Compile {
        /// Input loaf source file
        #[arg(short, long)]
        input: PathBuf,
        
        /// Output bytecode file (optional, defaults to input.loaf -> input.crouton)
        #[arg(short, long)]
        output: Option<PathBuf>,
        
        /// Pretty print the generated bytecode
        #[arg(long)]
        pretty: bool,
    },
    
    /// Run a loaf program directly
    Run {
        /// Input loaf source file
        #[arg(short, long)]
        input: PathBuf,
        
        /// Show detailed execution information
        #[arg(long)]
        verbose: bool,
    },
    
    /// Start an HTTP server with loaf endpoints
    Server {
        /// Input loaf source file containing endpoint definitions
        #[arg(short, long)]
        input: PathBuf,
        
        /// Port to listen on (default: 4271 = 0x10AF)
        #[arg(short, long, default_value = "4271")]
        port: u16,
        
        /// Show detailed server information
        #[arg(long)]
        verbose: bool,
    },
    
    /// Show information about a loaf source file
    Info {
        /// Input loaf source file
        #[arg(short, long)]
        input: PathBuf,
        
        /// Show symbol table
        #[arg(long)]
        symbols: bool,
        
        /// Show dependency graph
        #[arg(long)]
        deps: bool,
    },
}

pub struct CliHandler;

impl CliHandler {
    pub fn new() -> Self {
        Self
    }

    /// Execute the CLI command
    pub async fn handle(&self, cli: Cli) -> Result<()> {
        match cli.command {
            Commands::Compile { input, output, pretty } => {
                self.handle_compile(input, output, pretty).await
            }
            Commands::Run { input, verbose } => {
                self.handle_run(input, verbose).await
            }
            Commands::Server { input, port, verbose } => {
                self.handle_server(input, port, verbose).await
            }
            Commands::Info { input, symbols, deps } => {
                self.handle_info(input, symbols, deps).await
            }
        }
    }

    async fn handle_compile(&self, input: PathBuf, output: Option<PathBuf>, pretty: bool) -> Result<()> {
        println!("Compiling {}...", input.display());

        // Read source file
        let source = fs::read_to_string(&input)
            .map_err(|e| anyhow!("Failed to read input file: {}", e))?;

        // Compile the source
        let bytecode = self.compile_source(&source)?;

        // Determine output file
        let output_path = output.unwrap_or_else(|| {
            let mut path = input.clone();
            path.set_extension("crouton");
            path
        });

        // Write bytecode
        if pretty {
            let json = serde_json::to_string_pretty(&bytecode)?;
            fs::write(&output_path, json)?;
        } else {
            let json = serde_json::to_string(&bytecode)?;
            fs::write(&output_path, json)?;
        }

        println!("Compiled successfully to {}", output_path.display());
        println!("Generated {} instructions", bytecode.instructions.len());
        println!("Registered {} endpoints", bytecode.endpoints.len());

        Ok(())
    }

    async fn handle_run(&self, input: PathBuf, verbose: bool) -> Result<()> {
        if verbose {
            println!("Running {}...", input.display());
        }

        // Read and compile source
        let source = fs::read_to_string(&input)
            .map_err(|e| anyhow!("Failed to read input file: {}", e))?;

        let bytecode = self.compile_source(&source)?;

        if verbose {
            println!("Compilation completed:");
            println!("  Instructions: {}", bytecode.instructions.len());
            println!("  Constants: {}", bytecode.constants.len());
            println!("  Endpoints: {}", bytecode.endpoints.len());
        }

        // Create virtual machine and execute
        let vm = crate::runtime::VirtualMachine::new(bytecode);
        let mut heap = crate::runtime::IsolatedHeap::new();

        if verbose {
            println!("Executing program...");
        }

        let result = vm.execute(vm.program.entry_point, &mut heap).await?;

        // Display result
        match result {
            Some(value) => {
                println!("Program result:");
                match value {
                    crate::codegen::Value::String(s) => println!("{}", s),
                    crate::codegen::Value::Number(n) => println!("{}", n),
                    crate::codegen::Value::Boolean(b) => println!("{}", b),
                    crate::codegen::Value::Null => println!("null"),
                    other => println!("{}", serde_json::to_string_pretty(&other)?),
                }
            }
            None => {
                if verbose {
                    println!("Program completed without return value");
                }
            }
        }

        Ok(())
    }

    async fn handle_server(&self, input: PathBuf, port: u16, verbose: bool) -> Result<()> {
        println!("Starting loaf HTTP server on port {}...", port);

        // Read and compile source
        let source = fs::read_to_string(&input)
            .map_err(|e| anyhow!("Failed to read input file: {}", e))?;

        let bytecode = self.compile_source(&source)?;

        if verbose {
            println!("Compilation completed:");
            println!("  Instructions: {}", bytecode.instructions.len());
            println!("  Endpoints: {}", bytecode.endpoints.len());
        }

        // Display registered endpoints
        if !bytecode.endpoints.is_empty() {
            println!("Registered endpoints:");
            for endpoint in bytecode.endpoints.values() {
                println!("  {} {}", endpoint.method, endpoint.path);
            }
        } else {
            println!("Warning: No endpoints found in source file");
        }

        // Start server
        let server = LoafServer::new(bytecode, port);
        server.start().await?;

        // In a real implementation, this would keep the server running
        // For now, we'll simulate a simple request
        if verbose {
            println!("Simulating a test request...");
            let test_request = HttpRequest {
                method: "GET".to_string(),
                path: "/test".to_string(),
                headers: HashMap::new(),
                body: None,
                query_params: HashMap::new(),
            };

            match server.handle_request(test_request).await {
                Ok(response) => {
                    println!("Test response: {} {}", response.status, 
                        response.body.unwrap_or_else(|| "No body".to_string()));
                }
                Err(e) => {
                    println!("Test request failed: {}", e);
                }
            }
        }

        println!("Server simulation completed");
        Ok(())
    }

    async fn handle_info(&self, input: PathBuf, show_symbols: bool, show_deps: bool) -> Result<()> {
        println!("Analyzing {}...", input.display());

        // Read source file
        let source = fs::read_to_string(&input)
            .map_err(|e| anyhow!("Failed to read input file: {}", e))?;

        // Parse and analyze
        let mut lexer = Lexer::new(&source);
        let tokens = lexer.tokenize()?;
        println!("Tokens: {}", tokens.len());

        let mut parser = Parser::new(tokens);
        let ast = parser.parse()?;
        println!("AST nodes: {}", self.count_ast_nodes(&ast));

        let mut analyzer = SemanticAnalyzer::new();
        let analyzed = analyzer.analyze(&ast)?;
        println!("Symbols: {}", analyzed.symbol_table.symbols().len());
        println!("Assignments: {}", analyzed.resolution_order.len());

        if show_symbols {
            println!("\nSymbol Table:");
            for (name, symbol) in analyzed.symbol_table.symbols() {
                println!("  {} : {:?}", name, symbol.symbol_type);
                if !symbol.dependencies.is_empty() {
                    println!("    Dependencies: {:?}", symbol.dependencies);
                }
            }
        }

        if show_deps {
            println!("\nDependency Graph:");
            for (name, symbol) in analyzed.symbol_table.symbols() {
                if !symbol.dependencies.is_empty() {
                    println!("  {} -> {:?}", name, symbol.dependencies);
                }
            }
        }

        // Check for endpoints
        let endpoints: Vec<_> = analyzed.endpoints.iter()
            .map(|endpoint| format!("{:?} {} ({})", endpoint.method, endpoint.path, endpoint.name))
            .collect();

        if !endpoints.is_empty() {
            println!("\nHTTP Endpoints:");
            for endpoint in endpoints {
                println!("  {}", endpoint);
            }
        }

        // Check for promises
        let promises: Vec<_> = analyzed.symbol_table.symbols().iter()
            .filter_map(|(name, symbol)| {
                if matches!(symbol.symbol_type, crate::analyzer::Type::Promise(_)) {
                    Some(name.clone())
                } else {
                    None
                }
            })
            .collect();

        if !promises.is_empty() {
            println!("\nPromises:");
            for promise in promises {
                println!("  {}", promise);
            }
        }

        Ok(())
    }

    fn compile_source(&self, source: &str) -> Result<crate::codegen::BytecodeProgram> {
        // Tokenize
        let mut lexer = Lexer::new(source);
        let tokens = lexer.tokenize()
            .map_err(|e| anyhow!("Lexical analysis failed: {}", e))?;

        // Parse
        let mut parser = Parser::new(tokens);
        let ast = parser.parse()
            .map_err(|e| anyhow!("Parsing failed: {}", e))?;

        // Analyze
        let mut analyzer = SemanticAnalyzer::new();
        let analyzed = analyzer.analyze(&ast)
            .map_err(|e| anyhow!("Semantic analysis failed: {}", e))?;

        // Generate code
        let mut codegen = CodeGenerator::new();
        let bytecode = codegen.generate(&analyzed)
            .map_err(|e| anyhow!("Code generation failed: {}", e))?;

        Ok(bytecode)
    }

    fn count_ast_nodes(&self, node: &crate::parser::AstNode) -> usize {
        let mut count = 1;
        
        match node {
            crate::parser::AstNode::Object { fields, .. } => {
                for value in fields.values() {
                    count += self.count_ast_nodes(value);
                }
            }
            crate::parser::AstNode::Array { elements, .. } => {
                for element in elements {
                    count += self.count_ast_nodes(element);
                }
            }
            crate::parser::AstNode::Assignment { value, .. } => {
                count += self.count_ast_nodes(value);
            }
            crate::parser::AstNode::Binary { left, right, .. } => {
                count += self.count_ast_nodes(left);
                count += self.count_ast_nodes(right);
            }
            crate::parser::AstNode::Unary { operand, .. } => {
                count += self.count_ast_nodes(operand);
            }
            crate::parser::AstNode::HttpCall { body: Some(body), .. } => {
                count += self.count_ast_nodes(body);
            }
            _ => {}
        }
        
        count
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::NamedTempFile;
    use std::io::Write;

    #[tokio::test]
    async fn test_compile_command() {
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, r#"{{ "x": 42 }}"#).unwrap();
        
        let cli_handler = CliHandler::new();
        let result = cli_handler.handle_compile(
            temp_file.path().to_path_buf(),
            None,
            false
        ).await;
        
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_run_command() {
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, r#"{{ "result": 10 + 5 }}"#).unwrap();
        
        let cli_handler = CliHandler::new();
        let result = cli_handler.handle_run(
            temp_file.path().to_path_buf(),
            false
        ).await;
        
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_info_command() {
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, r#"{{ "endpoint": "@endpoint:GET:/test" }}"#).unwrap();
        
        let cli_handler = CliHandler::new();
        let result = cli_handler.handle_info(
            temp_file.path().to_path_buf(),
            true,
            true
        ).await;
        
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_server_command() {
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, r#"{{ "api": "@endpoint:GET:/hello" }}"#).unwrap();
        
        let cli_handler = CliHandler::new();
        let result = cli_handler.handle_server(
            temp_file.path().to_path_buf(),
            4271,
            true
        ).await;
        
        assert!(result.is_ok());
    }
}
